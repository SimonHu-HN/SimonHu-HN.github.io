<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SubLime 使用技巧|故障解决方案</title>
      <link href="/2020/07/07/SubLime-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7-%E6%95%85%E9%9A%9C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2020/07/07/SubLime-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7-%E6%95%85%E9%9A%9C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h2 id="date-2020-07-07-17-07-00"><a href="#date-2020-07-07-17-07-00" class="headerlink" title="date: 2020-07-07 17:07:00"></a>date: 2020-07-07 17:07:00</h2><h1 id="SubLime-使用技巧-故障解决方案"><a href="#SubLime-使用技巧-故障解决方案" class="headerlink" title="SubLime 使用技巧|故障解决方案"></a>SubLime 使用技巧|故障解决方案</h1><h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><hr><h3 id="故障解决"><a href="#故障解决" class="headerlink" title="故障解决"></a>故障解决</h3><hr><h4 id="·-中文乱码"><a href="#·-中文乱码" class="headerlink" title="· 中文乱码"></a>· 中文乱码</h4><p>情况一：Western 与 UTF-8冲突</p><p>某些文本文件可能由notepad书写，notepad处理中文的方式一般是将其编码为<code>Western (Windows 1252)</code>。 如果这样的文件日后用sublime打开的话，中文可能在第一时间呈现乱码状态，（如下图）。但一段时间后sublime可以自动转换为正确的中文显示。但是，如果你在sublime仍处于中文乱码的情况下就匆忙输入一些中文并按下保存（sublime会提示<strong>编码冲突</strong>），或者直接保存，那么此时的中文乱码也被保存了，日后再次打开sublime，它就无法将这些乱码转换显示为正确的中文。</p><p>解决方案：</p><p>如图操作，先把文本文档重新保存为原编码，再重新打开就可以了。</p><p><img src="https://raw.githubusercontent.com/SimonHu-HN/GoPic_Private/master/img/image-20200707172620978.png" alt="image-20200707172620978"></p><p>情况二：<a href="https://www.cnblogs.com/memset/archive/2013/05/29/3106999.html" target="_blank" rel="noopener">中文被编码成1个汉字4个字节</a></p>]]></content>
      
      
      <categories>
          
          <category> Sublime </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记|备忘录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python Code Library</title>
      <link href="/2020/06/09/Python-Code-Library/"/>
      <url>/2020/06/09/Python-Code-Library/</url>
      
        <content type="html"><![CDATA[<p><i class="fa fa-code blink-slow"></i><em>convenient for code write</em></p><p><strong>爬虫代码初始化模板</strong> </p><hr><p><em>作用：requests爬虫脚本初始化代码</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">url=<span class="string">""</span></span><br><span class="line">headers=&#123;&#125;</span><br><span class="line">proxies=&#123;</span><br><span class="line">   <span class="comment"># 'http': 'socks5://xxxx:5555',</span></span><br><span class="line">   <span class="comment">#  'https': 'socks5://xxxx:5555'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = requests.get(url_fix, proxies=proxies, headers=headers)</span><br><span class="line">soup = BeautifulSoup(result.content.decode(<span class="string">'utf-8'</span>), <span class="string">'lxml'</span>)</span><br><span class="line">target = soup.find(<span class="string">'div'</span>)</span><br></pre></td></tr></table></figure><p><strong>修正url中的#</strong> </p><hr><p><em>作用：防止待爬取目标的url中具有的#等特殊字符对爬虫进行干扰</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sharp_fix</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    the sharp (#) will incur some troubles in url</span></span><br><span class="line"><span class="string">    param: url</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> url.find(<span class="string">'#'</span>) &gt;= <span class="number">0</span>:</span><br><span class="line">        strs = url.split(<span class="string">'#'</span>)</span><br><span class="line">        <span class="keyword">if</span> is_chinese(strs[<span class="number">1</span>]):</span><br><span class="line">            fix = urllib.parse.quote(strs[<span class="number">1</span>])</span><br><span class="line">            fix = strs[<span class="number">0</span>] + <span class="string">'%23'</span> + fix</span><br><span class="line">            <span class="keyword">return</span> fix</span><br><span class="line">        <span class="keyword">return</span> url</span><br><span class="line">    <span class="keyword">return</span> url</span><br></pre></td></tr></table></figure><p><strong>判断字符串否包含中文</strong> </p><hr><p><em>作用：对字符串是否包含有中文字符进行判断</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_chinese</span><span class="params">(string)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    check whether the string includes the Chinese</span></span><br><span class="line"><span class="string">    param: string</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> string:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">u'\u4e00'</span> &lt;= ch &lt;= <span class="string">u'\u9fff'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pyton code library </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Code Library</title>
      <link href="/2020/06/09/Java-Code-Library/"/>
      <url>/2020/06/09/Java-Code-Library/</url>
      
        <content type="html"><![CDATA[<p><i class="fa fa-code blink-slow"></i><em>convenient for code write</em></p><p><strong>Java http post 代码(传递数据，使用Body传递)</strong> </p><hr><p><em>作用：使用java发起post请求,附带data于请求的Body中（非kv参数）</em></p><p><em>实例：模拟curl功能，可以将某些依托curl完成的数据库数据插入指令转换为java实现</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">http_post</span><span class="params">(String url, String port, String path, String content)</span> </span>&#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@Description</span>: ingest a address and send the content to it.</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@Example</span> http://localhost:8428/write + content</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> url url address</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> port remote address port</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> path remote address path</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> content metric data</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       String result = <span class="string">""</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           url = url + <span class="string">":"</span> + port + <span class="string">"/"</span> + path;</span><br><span class="line">           System.out.println(url);</span><br><span class="line">           URL realUrl = <span class="keyword">new</span> URL(url);</span><br><span class="line">           URLConnection conn = realUrl.openConnection();</span><br><span class="line">           conn.setRequestProperty(<span class="string">"accept"</span>, <span class="string">"*/*"</span>);</span><br><span class="line">           conn.setRequestProperty(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">           conn.setDoOutput(<span class="keyword">true</span>);</span><br><span class="line">           conn.setDoInput(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// fill and send content</span></span><br><span class="line">           DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(conn.getOutputStream());</span><br><span class="line">           dos.write(content.getBytes());</span><br><span class="line">           dos.flush();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// get response (Do not comment this line, or the data insertion will be failed)</span></span><br><span class="line">           BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(conn.getInputStream()));</span><br><span class="line">           String line;</span><br><span class="line">           <span class="keyword">while</span> ((line = in.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">             result += line;</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(result);<span class="comment">//</span></span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           System.out.println(<span class="string">"Exception,"</span> + e.getMessage());</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java code library </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker ToolBox设置及内外网访问</title>
      <link href="/2020/05/21/Docker-ToolBox%E8%AE%BE%E7%BD%AE%E5%8F%8A%E5%86%85%E5%A4%96%E7%BD%91%E8%AE%BF%E9%97%AE/"/>
      <url>/2020/05/21/Docker-ToolBox%E8%AE%BE%E7%BD%AE%E5%8F%8A%E5%86%85%E5%A4%96%E7%BD%91%E8%AE%BF%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-ToolBox设置及内外网访问"><a href="#Docker-ToolBox设置及内外网访问" class="headerlink" title="Docker ToolBox设置及内外网访问"></a>Docker ToolBox设置及内外网访问</h1><h3 id="环境版本"><a href="#环境版本" class="headerlink" title="环境版本"></a>环境版本</h3><hr><p>Docker-toolbox：<a href="https://github.com/docker/toolbox/releases/tag/v19.03.1" target="_blank" rel="noopener">v19.03.1</a></p><p>Boot2docker：<a href="https://github.com/boot2docker/boot2docker/releases/tag/v19.03.5" target="_blank" rel="noopener">v19.03.5</a></p><p>OS: Win 8.1</p><h3 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h3><hr><p>在windows系列中如果想要运行docker，除了win10之后，所有的系统都需要下载docker-toolbox来实现docker的正确安装与运行。docker-toolbox的安装暂且不提，比较简单。</p><p>有一点要注意，安装完成之后，点击<strong>Docker Quickstart Terminal</strong>来实现docker的启动，这时他会检查本地是否有正确的boot2docker.iso文件，这个文件在安装位置的DockerToolbox文件夹下是有一个默认的（但版本不是最新的），你也可以自己去<a href="https://github.com/docker/toolbox/releases/tag/v19.03.1" target="_blank" rel="noopener">这里</a>下载最新的版本，随后将下载好的iso文件丢到<code>C:\Users\yourusername\.docker\machine\cache</code>下，切记位置要正确，因为<code>.docker\machine\cache</code>这个路径在电脑上不止有一个，还有一个是在<code>C:\Users\yourusername\AppData</code>下，不要放错了位置。成功放好之后，检查成功，docker就可以正确启动了。</p><p><img src="https://raw.githubusercontent.com/SimonHu-HN/GoPic_Private/master/img/image-20200521163240217.png" alt="大鲸鱼"></p><h3 id="镜像修改问题"><a href="#镜像修改问题" class="headerlink" title="镜像修改问题"></a>镜像修改问题</h3><hr><p>安装之后，需要修改docker镜像源以解决pull的速度太慢的问题，以<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors" target="_blank" rel="noopener">阿里云镜像加速服务</a>为例</p><p><img src="https://raw.githubusercontent.com/SimonHu-HN/GoPic_Private/master/img/image-20200521163507216.png" alt="image-20200521163507216"></p><p>按照上图就可以解决源的问题，但一般在docker第一次启动时，default就已经被创建好了，所以你需要先↓</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine stop default</span><br><span class="line">$ docker-machine rm default</span><br></pre></td></tr></table></figure><p>把原先的机器删除之后，再按照阿里云的教程来做，不然会失败，提示default机器已存在。（当然你也可以不删除default，而是新建一个其他名字的机器也行）</p><h3 id="内外网访问问题"><a href="#内外网访问问题" class="headerlink" title="内外网访问问题"></a>内外网访问问题</h3><hr><p>docker-toolbox的原理是先生成一个由virtualbox模拟出的linux环境。在电脑中搜索点击virtualbox，打开之后就可以看到由toolbox生产的那个default机器</p><p><img src="https://raw.githubusercontent.com/SimonHu-HN/GoPic_Private/master/img/image-20200521164050280.png" alt="image-20200521164050280"></p><p>如果以上都没问题，那么你离访问你想要的容器只差最后几步。</p><p>首先你需要现在命令行里pull你想要的容器，这个过程应该很快，只要你正确配置了源</p><p><img src="https://raw.githubusercontent.com/SimonHu-HN/GoPic_Private/master/img/image-20200521164306797.png" alt="image-20200521164306797"></p><p>这里我以pull prometheus（开源时序数据库，端口为9090）为例，即以下面的命令运行prometheus</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name prometheus -d -p 127.0.0.1:9090:9090 prom/prometheus</span><br></pre></td></tr></table></figure><p>这个时候你在自己的电脑上（宿主机）输入localhost:9090是访问不到容器的，这是因为目前docker容器所运行的环境不过是virtualbox的linux虚拟环境，此时就有两种方法可以让你成功访问到你想要的容器。</p><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>先选中default机器（目标机器，这里我演示的时候用的是default），点击左上角设置，找到网络部分的端口转发规则，按照如下图方式填写，（192.168.99.100是默认的IP地址，如果你不确定你的IP地址是不是这个，你可以从<strong>Docker Quickstart Terminal</strong>启动后出现的大鲸鱼下面内找到你的默认IP地址)。按照如下规则填写之后，就可以直接在宿主机输入localhost:9090访问到想要的容器。</p><p><img src="https://raw.githubusercontent.com/SimonHu-HN/GoPic_Private/master/img/image-20200521164717285.png" alt="image-20200521164717285"></p><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>方法二过程没有那么麻烦，你不需要去配置网络，但是最后的访问可能比方法一要麻烦点。我们只需要将docker容器的启动命令修改为如下，（仍以prometheus启动为例）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### old : $ docker run --name prometheus -d -p 127.0.0.1:9090:9090 prom/prometheus</span></span><br><span class="line">$ docker run --name prometheus -d -p 9090:9090 prom/prometheus</span><br></pre></td></tr></table></figure><p>这个时候你就可以直接在宿主机的浏览器输入192.168.99.100:9090访问到你想要的容器内容。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub项目创建管理笔记</title>
      <link href="/2020/05/20/GitHub%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA%E7%AE%A1%E7%90%86%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/05/20/GitHub%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA%E7%AE%A1%E7%90%86%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="GitHub项目创建管理笔记"><a href="#GitHub项目创建管理笔记" class="headerlink" title="GitHub项目创建管理笔记"></a>GitHub项目创建管理笔记</h1><h3 id="pull-requests-与-merge"><a href="#pull-requests-与-merge" class="headerlink" title="pull requests 与 merge"></a>pull requests 与 merge</h3><hr><p>如果你想对他人的仓库代码有所贡献，首先你需要fork别人的仓库，随后将内容git clone到本地进行修改。以上过程推荐在Github Desktop的辅助下进行，（即使你命令行能力很强，desktop都有着很好的便捷性）</p><p><img src="https://raw.githubusercontent.com/SimonHu-HN/GoPic_Private/master/img/image-20200520171045263.png" alt="image-20200520171045263"></p><p><img src="https://raw.githubusercontent.com/SimonHu-HN/GoPic_Private/master/img/image-20200520171403086.png" alt="image-20200520171403086"></p><img src="https://raw.githubusercontent.com/SimonHu-HN/GoPic_Private/master/img/image-20200520171459828.png" alt="image-20200520171459828" style="zoom: 67%;" /><p>通过上面三张图所展示的步骤，就完成了准备阶段。此时你就可以在本地直接对项目进行修改，你所对此项目做出的增删改都会被github desktop记录，位置如下图：</p><p><img src="https://raw.githubusercontent.com/SimonHu-HN/GoPic_Private/master/img/image-20200520172605812.png" alt="image-20200520172605812"></p><p>当你确认你所有的修改都是符合你的意图的之后就可以点击commit，输入summary，description （summary是你对这次代码修改内容的一个概括性标题，description是详细描述，这些都是为了方便代码原有者最快了解你的修改意图）</p><p><img src="https://raw.githubusercontent.com/SimonHu-HN/GoPic_Private/master/img/image-20200520172953739.png" alt="image-20200520172953739"></p><p><img src="https://raw.githubusercontent.com/SimonHu-HN/GoPic_Private/master/img/image-20200520173204934.png" alt="image-20200520173204934"></p><p>随后你就可以去浏览器上输入你刚刚fork之后生成的仓库地址，这时候就可以看到页面上有一个pull requests和compare，前者是把当前的改变提交给源仓库，后者是方便你再提交前再次确认一下你的改动内容。点击pull request之后，在跳转的页面再点击 create pull requests，之后整个过程就完成了。</p><p><img src="https://raw.githubusercontent.com/SimonHu-HN/GoPic_Private/master/img/image-20200520173825422.png" alt="image-20200520173825422"></p><img src="https://raw.githubusercontent.com/SimonHu-HN/GoPic_Private/master/img/image-20200520173900005.png" alt="image-20200520173900005" style="zoom:50%;" /><p>当然，这部分只是你这里完成了。源仓库持有者会审核你的这次commit，在审核完毕后，会手动同意并merge，你的贡献就达到了。</p><p>但是要注意，目前很多大型开源项目在接受pull requests前会先使用自动化的代码检测工具对你的这次代码改动进行检测，内容大概是：针对你的代码是否可执行，格式是否规范等等，只有全部测试成功，源仓库持有者才会手动同意你的这次代码贡献。（所以一定要看清源仓库提交代码贡献前要满足的条件）</p><img src="https://raw.githubusercontent.com/SimonHu-HN/GoPic_Private/master/img/image-20200520174432113.png" alt="image-20200520174432113" style="zoom: 67%;" /><h3 id="Rich-the-Project-Index"><a href="#Rich-the-Project-Index" class="headerlink" title="Rich the Project Index"></a>Rich the Project Index</h3><hr><p>自己的项目仓库成功创建之后，就需要好好充实一下<code>README.md</code>，所以markdown的排版美感一定要掌握。同时一些认证的badge也可以让你的源项目看起来更正式，同时这些badge背后的工具也可以让你发现代码里的不足。</p><p>你可以在<a href="https://github.com/marketplace" target="_blank" rel="noopener">这里</a>explore你想要的工具。下面介绍些常用的工具和使用方法</p><h4 id="0-Create-your-own-badge"><a href="#0-Create-your-own-badge" class="headerlink" title="0.  Create your own badge"></a>0.  Create your own badge</h4><p>有一些badge是需要你自己创造的，比如你当前项目的语言依赖性，这个只有你自己比较清楚，所以这个时候就要去<a href="https://shields.io/" target="_blank" rel="noopener">shield.io</a>上自己生成svg文件，随后拿到markdown链接，放在<code>README.md</code>里。</p><p><img src="https://raw.githubusercontent.com/SimonHu-HN/GoPic_Private/master/img/image-20200520201018369.png" alt="image-20200520201018369"></p><p>打开网页后找到此处，输入你想DIY的信息，例如我想声明该项目build with python3.5，那么就可以如下设置：</p><p><img src="https://raw.githubusercontent.com/SimonHu-HN/GoPic_Private/master/img/image-20200520201043051.png" alt="image-20200520201043051"></p><p>之后再点击Make Badge,生成效果如图<img src="https://raw.githubusercontent.com/SimonHu-HN/GoPic_Private/master/img/image-20200520201129814.png" alt="image-20200520201129814" style="zoom: 67%;" />。最后一步，复制地址栏中的url，复制到<code>README.md</code>里，done！（按理说url应该以.svg结尾，但是chrome最新版里我看不到svg字段，不知道是浏览器的原因还是它本身生成的url就不自带.svg后缀了，如果没有.svg，记得复制url后加上.svg，这样才可以正确显示)</p><h4 id="1-Travis-CI"><a href="#1-Travis-CI" class="headerlink" title="1. Travis-CI"></a>1. <a href="https://travis-ci.com/" target="_blank" rel="noopener">Travis-CI</a></h4><p>Travis CI 提供的是持续集成服务（Continuous Integration，简称 CI）。它绑定 Github 上面的项目，只要有新的代码，就会自动抓取。然后，提供一个运行环境，执行测试，完成构建，还能部署到服务器。</p><p>持续集成指的是只要代码有变更，就自动运行构建和测试，反馈运行结果。确保符合预期以后，再将新代码”集成”到主干。</p><p>持续集成的好处在于，每次代码的小幅变更，就能看到运行结果，从而不断累积小的变更，而不是在开发周期结束时，一下子合并一大块代码。</p><p>以<strong>Python</strong>项目为例，当你的项目创建仓库成功后，登入travis-ci，关联你github账号，随后你就在travis-ci可以浏览到自己github里的仓库列表，而此时任何CI-task都不会生效的，因为你还需要在你的项目中添加一个 <code>.travis.yml</code> 文件，其具体编写格式详见<a href="https://docs.travis-ci.com/user/languages/python/" target="_blank" rel="noopener">此处</a>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">python</span></span><br><span class="line"><span class="attr">python:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"2.7"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"3.4"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"3.5"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"3.6"</span>      <span class="comment"># current default Python on Travis CI</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"3.7"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"3.8"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"3.8-dev"</span>  <span class="comment"># 3.8 development branch</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"nightly"</span>  <span class="comment"># nightly build</span></span><br><span class="line"><span class="comment"># command to install dependencies</span></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">-r</span> <span class="string">requirements.txt</span></span><br><span class="line"><span class="comment"># command to run tests</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pytest</span></span><br></pre></td></tr></table></figure><p>以上面的模板为例，通过k:v的方式就能很直白的读懂这个模板yml文件，<code>language</code>指定当前项目语言，之后再根据当前项目的语言类型选择它所要进行测试的版本号，随后的<code>install</code>则是安装一些必须的库依赖。<code>script</code>则是你执行这个项目的命令代码。</p><h4 id="2-Codecov"><a href="#2-Codecov" class="headerlink" title="2. Codecov"></a>2. <a href="https://codecov.io/" target="_blank" rel="noopener">Codecov</a></h4><p>它是负责你集成测试你的代码覆盖率的工具，常常与CI与code coverage配合使用，大致流程就是使用code coverage类的测试工具生成report，由codecov命令找到你这个report显示到它那里。</p><p>以codecov与上面的travis-ci相配合为例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">python</span></span><br><span class="line"><span class="attr">python:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"3.5"</span></span><br><span class="line"><span class="comment"># command to install dependencies</span></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">-r</span> <span class="string">requirements.txt</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">coverage</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">codecov</span></span><br><span class="line"><span class="comment"># command to run tests</span></span><br><span class="line"><span class="attr">script:</span> <span class="string">python3</span> <span class="string">Main.py</span></span><br><span class="line"><span class="attr">after_success:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">coverage</span> <span class="string">run</span> <span class="string">Main.py</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">codecov</span></span><br></pre></td></tr></table></figure><p>注意这里的<code>after_success</code>，它的功能是在上面的<code>script</code>执行成功之后，才做出的一系列命令操作。可以看到首先用coverage run 执行我的主程序，这条命令结束之后，coverage report也就生成了，随后再使用codecov命令。通过上述操作，就可以codecov网站里找到对应的项目代码覆盖率信息报告，而此时你也可以在这个报告页面拿到你想要的badge。</p><h4 id="3-CodeFactor"><a href="#3-CodeFactor" class="headerlink" title="3. CodeFactor"></a>3. <a href="https://www.codefactor.io/" target="_blank" rel="noopener">CodeFactor</a></h4><p>代码结构分析，它会根据你的代码规范性来给出适当的评价。操作简单，无需多言，只要将它与github账户绑定，授权库的访问，就可以点击库列表中的某些库，分析出结果，随后拿到badge。</p><h4 id="4-To-be-continued……"><a href="#4-To-be-continued……" class="headerlink" title="4. To be continued……."></a>4. To be continued…….</h4><p>…………….</p>]]></content>
      
      
      <categories>
          
          <category> GitHub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记|备忘录 </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/05/13/hello-world/"/>
      <url>/2020/05/13/hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="初来乍到"><a href="#初来乍到" class="headerlink" title="初来乍到"></a>初来乍到</h2><h4 id="如果你有幸看到这"><a href="#如果你有幸看到这" class="headerlink" title="如果你有幸看到这"></a>如果你有幸看到这</h4><p>说明你很爱乱逛，这个博客不宣传不恰饭。写的都是my life，或者是学习经验。</p><p>整站主体语言是中文，有时候会夹杂些许英文。有时候会整篇都是英文，以此练手。</p><p>技术文章大部分都是真实可信的，写的技术点偏向细节，并且基本上都针对最新版本。</p><p>整个博客涉及的技术内容不限，我最近玩什么，尝试什么，就会写下来。</p><p>如果你在阅览我的博客主页或文章后有好的意见，或我有严重错误之处，<a href="https://simonhu-hn.github.io/about/" target="_blank" rel="noopener">请联系我</a>，多谢。</p><hr><p>本博客网站维护使用大致由下列工具与技术组成</p><p>├── Local<br>│   ├── <a href="https://www.typora.io/" target="_blank" rel="noopener">Typora</a> （撰写与维护文本内容）<br>│   ├── <a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a> （图床，图片内容）</p><p>├── Online<br>│   ├── <a href="https://pages.github.com/" target="_blank" rel="noopener">Github Pages</a>（白嫖服务器）<br>│   ├── <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> （博客系统，SSH deploy部署，Hexo-admin 偶尔管理）<br>│   ├── <a href="http://wzpan.github.io/hexo-theme-freemind-blog/" target="_blank" rel="noopener">hexo-theme-freemind</a> （原生主题）<br>│   ├── <a href="https://matrix.to/#/!MHVhJvFpOwpTWazTnT:matrix.org?via=matrix.org" target="_blank" rel="noopener">FontAwesome</a>（图标库）<br>│   └── <a href="https://analytics.google.com/" target="_blank" rel="noopener">Google Analytics</a> </p><p>我的Brain提供主要技术支持。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python笔记与备忘录</title>
      <link href="/2020/05/11/Python_Note/"/>
      <url>/2020/05/11/Python_Note/</url>
      
        <content type="html"><![CDATA[<h1 id="Python笔记与备忘录"><a href="#Python笔记与备忘录" class="headerlink" title="Python笔记与备忘录"></a>Python笔记与备忘录</h1><p>本页面记录本人在编写python项目时遇到的所有陷阱和技巧 （update forever）</p><h2 id="爬虫篇"><a href="#爬虫篇" class="headerlink" title="爬虫篇"></a>爬虫篇</h2><hr><h3 id="坑、陷阱-Pitfall"><a href="#坑、陷阱-Pitfall" class="headerlink" title="坑、陷阱 / Pitfall"></a>坑、陷阱 / Pitfall</h3><ol><li><h4 id="headers构造空格"><a href="#headers构造空格" class="headerlink" title="headers构造空格"></a>headers构造空格</h4><p>从浏览器开发者工具复制下来的<a href="#headers构造">headers</a>一定要注意把空格消除。不然会被视为invalid headers.</p></li><li><h4 id="selector规则构造"><a href="#selector规则构造" class="headerlink" title="selector规则构造"></a>selector规则构造</h4><p>如果以同样的select rule 应用于所有页面，最后的结果却是部分数据缺失，99%的情况都是这些页面上要么没有你的rule中构造好的id or class，要么就是rule中的id和class所应用在的元素和其他页面不一样。</p></li><li><h4 id="nth-of-type与-nth-child"><a href="#nth-of-type与-nth-child" class="headerlink" title="nth-of-type与:nth-child"></a>nth-of-type与:nth-child</h4><p>nth-of-type被Beautifulsoup支持，后者不被支持</p></li><li><h4 id="select规则书写规范"><a href="#select规则书写规范" class="headerlink" title="select规则书写规范"></a>select规则书写规范</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">The combinator &#39;x&#39; at postion xx, must have a selector before it</span><br><span class="line">此错误不是任何时候都会报错，但是要注意书写规范，在select rule不要多空格或者其他乱七八糟的字符在</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">&#39;.mw-parser-output &gt; ul:nth-of-type(&#123;&#125;) &gt; li a&#39; #正确写法</span><br><span class="line">&#39;.mw-parser-output  &gt; ul:nth-of-type(&#123;&#125;) &gt; li a&#39; #多了一个空格报错</span><br></pre></td></tr></table></figure></li><li><h4 id="中文字符显示不全"><a href="#中文字符显示不全" class="headerlink" title="中文字符显示不全"></a>中文字符显示不全</h4><p>原因在于网页大都采用UTF-8字符集，该字符集缺字严重，连国务院2013年8月19日公布的8105个通用规范汉字（均为简体汉字）都不能全部显示出来，共缺249个汉字，复其中4个二级字，245个三级字。</p><p>一种可行的解决方法是：以维基百科为例，如果你爬取的是简体页面，那么你可以尝试寻找该页面是否有繁体中文版本，繁体字被爬取下来的时候是可以正常显示的</p></li><li><h4 id="Url中的"><a href="#Url中的" class="headerlink" title="Url中的#"></a>Url中的#</h4><p>在scrapy爬虫框架中会自动过滤掉#后面的内容，网络请求的时候“#”后面的参数会被忽略，解决方法<a href="#处理url中的sharp">T-4</a>。</p></li></ol><h3 id="技巧-Tech"><a href="#技巧-Tech" class="headerlink" title="技巧 / Tech"></a>技巧 / Tech</h3><hr><ol><li><h6 id="headers构造"><a href="#headers构造" class="headerlink" title="headers构造"></a>headers构造</h6><p>构造请求头（headers）时，可以直接从chrome的调试工具处复制真实的请求头</p><p><img src="https://raw.githubusercontent.com/SimonHu-HN/GoPic_Private/master/img/image-20200520153948246.png" alt="image-20200520153948246"></p><p>然后此时还需要一点小微操就可以正确使用，以Pycharm为例，按Ctrl+R调出Regex匹配模式</p><p><img src="https://raw.githubusercontent.com/SimonHu-HN/GoPic_Private/master/img/image-20200520162051277.png" alt="image-20200520162051277"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">分别输入</span><br><span class="line">(.*?):(.*)</span><br><span class="line">&#39;$1&#39;:&#39;$2&#39;</span><br></pre></td></tr></table></figure><p>此时带有正确引号包裹的一个个headers键值对就构造好了。</p></li><li><h6 id="url中文处理"><a href="#url中文处理" class="headerlink" title="url中文处理"></a>url中文处理</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">urllib.parse.unquote</span><br><span class="line"><span class="comment"># 解码</span></span><br><span class="line">print(urllib.parse.unquote(<span class="string">'%B1%E0%C2%EB%BF%D3%B5%F9'</span>))</span><br><span class="line">坑爹</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编码</span></span><br><span class="line">urllib.parse.quote</span><br><span class="line">print(urllib.parse.quote(<span class="string">'坑爹'</span>))</span><br><span class="line"><span class="string">'%B1%E0%C2%EB%BF%D3%B5%F9'</span></span><br></pre></td></tr></table></figure></li><li><h6 id="判断字符串中是否有中文字符"><a href="#判断字符串中是否有中文字符" class="headerlink" title="判断字符串中是否有中文字符"></a>判断字符串中是否有中文字符</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_chinese</span><span class="params">(string)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    check whether the string includes the Chinese</span></span><br><span class="line"><span class="string">    param: string</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> string:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">u'\u4e00'</span> &lt;= ch &lt;= <span class="string">u'\u9fff'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></li><li><h6 id="处理url中的sharp"><a href="#处理url中的sharp" class="headerlink" title="处理url中的sharp"></a>处理url中的sharp</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 处理url中的#号</span><br><span class="line"># 把#(sharp)转为%23</span><br><span class="line">def sharp_fix(url):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    the sharp (#) will incur some troubles in url</span><br><span class="line">    param: url</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if url.find(&#39;#&#39;) &gt;&#x3D; 0:</span><br><span class="line">        strs &#x3D; url.split(&#39;#&#39;)</span><br><span class="line">        if is_chinese(strs[1]):</span><br><span class="line">            fix &#x3D; urllib.parse.quote(strs[1])</span><br><span class="line">            fix &#x3D; strs[0] + &#39;%23&#39; + fix</span><br><span class="line">            return fix</span><br><span class="line">        return url</span><br><span class="line">    return url</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 笔记|备忘录 </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
